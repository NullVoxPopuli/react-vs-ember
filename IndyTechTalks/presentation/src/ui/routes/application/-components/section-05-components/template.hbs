<SectionTitleSlide as |s|>
  <s.Title>Components and Local State</s.Title>

  <s.Notes data-markdown>
    Easiest to compare, cause most parallels
  </s.Notes>
</SectionTitleSlide>

<DemoSlide>
  <EmberComponent />
</DemoSlide>

<CodeSlide class='react-color' @title='React' @name='react-component.tsx' />
<CodeSlide class='ember-color' @title='Ember' @name='ember-component.ts' as |s|>
  <s.Notes data-markdown>
    Be sure to mention computed property render optimization

    @action is currently a semantic differentiator for an action that is exposed to the template
  </s.Notes>
</CodeSlide>

<CodeSlide class='react-color' @title='React' @name='react-component-template.tsx' />
<CodeSlide class='ember-color' @title='Ember' @name='ember-component-template.hbs' as |s|>
  <s.Notes data-markdown>
    interrupt self to show handlebars place
  </s.Notes>
</CodeSlide>

<Slide as |s|>
  <Image @of='handlebars.png' />
  <s.Notes data-markdown>
    - noticed this yesterday
  </s.Notes>
</Slide>
<CodeSlide class='ember-color' @title='Ember' @name='ember-component-template.hbs' />

<Slide as |s|>
  <h3 class='ember-color'>Sparkles</h3>
  <Image @of='robin-sparkles.gif' />

  <s.Notes data-markdown>
    component manager -- allows for custom implementations of components
  </s.Notes>
</Slide>

<Slide as |s|>
  <h3 class='ember-color'>Ember Sparkles</h3>

  <div class='flex-row'>
    <s.LeftCode @noScroll={{true}} @name='sparkles-component.ts' />
    <s.RightCode @name='sparkles-component-template.hbs' />
  </div>


  <s.Notes data-markdown>
    this particular implementation is native javascript/typescript, no need for this.set or this.setState from react.

    the tracked decorator extracts the need to manage the component-level state asynchrony and batch-updating yourself


  </s.Notes>
</Slide>

